## Входные данные:
1) Файл размером 1тб.
2) ОЗУ 500мб.
3) Надо отсортировать файл.

Смысл задачи в том, что нельзя положить весь файл 
с числами в ОЗУ, для того, чтобы его отсортировать.

**хотя конечно я согласовал числа от 0 до 1000**

Но вы же хотите не этого!

Почему? Потому что в таком случае, если диапазон 
чисел небольшой, то весь этот 1тб считывается стримом
и сортируется с помощью ПОДСЧЕТА.

А еще, потому что в уточнении было написано, что:

*Предполагается, что сортировка реализуется с 
использованием временных файлов на диске*

Сортировка подсчетом, это когда мы считаем, сколько
у нас каких чисел, и составляем таблицу, например:

```5 3 2 7 9 0 1 5 3 2```

Превратится в такую таблицу:

| 0   | 1   |
|-----|-----|
| 1   | 1   |
| 2   | 2   |
| 3   | 2   |
| 4   | 0   |
| 5   | 1   |
| 6   | 0   |
| 7   | 1   |
| 8   | 0   |
| 9   | 1   |

Из которой потом создается отсортированный массив:

```0 1 1 2 2 3 3 5 7 9```

Соответственно таблица из 1001 полей легко поместится в 500мб.

## Структура входного файла:
Допустим, что все же в нем будут цифры от 0 до 1000, а файл будет текстовым.
Поэтому числа будут представлены в виде строк с разделителем в виде переноса строки ```\n```


Все это в кодировке **UTF-8**

Пример:
```
0
100
3
50
100
90
388
999
```

## Решение:
В общем из-за некоторых более важных проектов, которыми я сейчас занимаюсь, 
я сделал только самое простое решение с помощью сортировкой подсчетов,
которое удовлетворит требования, которые я согласовал. 

Вся сортировка в `main.js`, в `utils.js` есть функция 
`isSorted`, которую предполагалось использовать в каком-нибудь тестовом фреймворке,
но конкретно сейчас там просто захардкожено имя файла `testFile2Sorted.txt`.


#### Но как предполагалось решать ваше задание изначально:
1) Разделить файл на много файлов, размер каждого из которых можно отсортировать в доступной ОЗУ.
2) Отсортировать каждый файл по отдельности.
3) К каждому файлу сделать стрим на чтение, и один стрим на запись итогового файла.
4) Читать по одному значению из файла и сравнивать его со всеми значениями, и соответственно брать меньшее число.
5) Читатать следующее значение из файла, из которого до этого было выбрано минимальное число.
6) Делать так, пока не обработаем все файлы (файлы будут заканчиваться в разное время, поэтому количество стримов на чтение со временем будет уменьшаться).
7) Удалить ненужные файлы.

Ну и для того, чтобы проверить, что все работает, надо было взять какой-нибудь *Jest* и написать в нем тестовые случаи, в том числе с генерацией достаточно объемных файлов (которые будут псевдоперемешенные, хотя на самом деле будут содержать заранее известное количество каждых чисел)

Ну и по хорошему еще конечно сделать тесты производительности, тесты памяти и т.д., но это если бы у нас было бы что-нибудь промышленное, и надо было понять, что наши супер серваки не упадут во время активной обработки данных!!

А пока сделал тяп ляп, потому что занимаюсь сейчас другими проектами, более интресными, чем сортировать числа))